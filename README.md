"Компилятор" для EDSAC
============================

Эта штука позволит студентам Поликека значительно облегчить себе жизнь
тем, что не придётся высчитывать адреса в программах самим.
Также оно может объявлять переменные и присваивать им значения
более очевидным способом.

Как пользоваться?
----------------------------

    ./edsac.exe [-12dh] [--help] [--io <1|2>] [--debug] [--input <input_filename>] [--output <output_filename>]

Аргументы:
- *io* -- позволяет указать тип Initial Orders, по умолчанию используется 2.
- *debug* -- выводит дополнительную информацию: названия переменных, объявления блоков данных, деректив и номера инструкций в памяти.
- *input* -- программа, которую нужно преобразовать в формат EDSAC Simulator (если не указано, то используется стандартный ввод).
- *output* -- файл, куда необходимо записать результат преобразования (если не указано используется стандартный вывод).

Кратко о возможностях
----------------------------

В начале программы, до всех инструкций можно указать директиву `~io`. Она позволяет указать тип Initial Orders внутри файла
программы. В таком случае аргумент *io* в командной строке будет проигнорирован. Пример её использования показан ниже в
программах сложения двух чисел.

Точки перехода программы можно помечать следующим образом:
```
start:
    T4535F
loop:
    S7676F
    E loop F
```
В примере выше точками перехода являются метки *start* и *loop*. Также показан пример их использования `E loop F`.
Эти переходы работают во всех Initial Orders. edsacc автоматически расправляется с переходами, даже когда они сделаны так: `E loop @`.

Можно объявить переменные следующим образом:
```
$varka = 34
$long_var = 56l
$short_var=3s
```
Далее по ходу использования программы на них можно ссылаться также, как и на точки перехода.
Переменные не обязаны объявляться до начала программы. На них можно ссылаться, даже если они объявлены в конце.

Также существуют массивы, их можно объявлять так:
```
$array={ 0, 1, 2, 3, 4, 5 }
$array2=[12]
$array3=[23]{ 0s, 3l, 5 }
```

При обращении к переменной array будет адресовываться первый элемент массива.
Цифра в квадратных скобках означает количество элементов в массиве.

При написании программы можно использовать комментарии в стиле C, а также комментарии в квадратных скобках (не везде).

Полезные константы
----------------------

Преобразование программы с Initial Orders 1 и 2 позволяет использовать переменную *LAST_INSTRUCTION*,
которая ссылается на адрес после последней инструкции. Невероятно полезная константа для Initial Orders 1.
Она применяется в первой же инструкции так: `T LAST_INSTRUCTION S`.

Для Initial Orders 2 существует несколько дополнительных констант.
- *ONE* -- адрес переменной с единицей для увеличения адреса (с двойкой по сути).
- *ZERO* -- адрес переменной с нулём.
- *RETURN* -- адрес переменной с чтукой для "формирования инструкции возврата в замкнутых подпрограммах".

Пример программы сложения двух чисел на Initial Orders 2
-------------------------------------------------------------

```
// Specify Initial Orders 2 for this program
~io 2
// Variables
$a = 4
$b = 178
$result = 0

start:
    T LAST_INSTRUCTION F // Clear acc
    A a F       // Add a
    A b F       // Add b
    U result F  // Write the sum to result
    ZF          // exit

    E start K PF
```

Пример программы сложения двух чисел на Initial Orders 1
-------------------------------------------------------------

```
// Specidy Initial Orders 1
~io 1

T LAST_INSTRUCTION S
E start S

// Variables
$a = 4
$b = 178
$result = 0

start:
    A a S       // Add a
    A b S       // Add b
    U result S  // Write the sum to result
    ZS          // exit
```

Недавно были добавлены циклы и индексация массивов.

Вот пример:
```
~io 1

T LAST_INSTRUCTION S
E start S

// Variables
$a = { 5, 25, 24, 0, 1 } // Объявление массива с операцией сложения элементов в acc.
$N = 5

// Объявление переменных с метаданными edsacc
// (нужно для массивов и циклов for)
~use_special_vars

start:
    T LAST_INSTRUCTION S // Clear acc
    A N S
    for $i=0, N do
        A a[i] S // Сложение всех элементов в массиве
    end
    ZS // В acc находится сумма всех элементов + N = 60

```

Индексировать массивы можно любыми переменными, выход за границы массива при этом не отслеживается.
Также можно индексировать массивы, используя числа.
